from src.keyboards.admin import get_hw_review_kb
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery
import os
import glob
import logging
from src.utils.db import DB_PATH,  safe_db_operation, get_courses_data, get_next_lesson, get_pending_homeworks
import aiosqlite
from src.config import get_lesson_delay, is_test_mode, TEST_MODE, extract_delay_from_filename
from datetime import datetime, timedelta  
import pytz


# –û—Ç–∫–ª—é—á–∞–µ–º DEBUG –ª–æ–≥–∏ –¥–ª—è aiosqlite
logging.getLogger('aiosqlite').setLevel(logging.WARNING)

router = Router()

from aiogram import Bot

logger = logging.getLogger(__name__)


async def notify_admins(hw_id: int, user_id: int, file_id: str, bot: Bot):
    try:
        admin_chat = os.getenv('ADMIN_GROUP')
        if not admin_chat:
            raise ValueError("Admin group ID not configured")
            
        await bot.send_photo(
            admin_chat,
            file_id,
            caption=f"üìù –ù–æ–≤–∞—è –¥–æ–º–∞—à–Ω—è—è —Ä–∞–±–æ—Ç–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}",
            reply_markup=get_hw_review_kb(hw_id)
        )
    except Exception as e:
        logger.error(f"9999 | Failed to notify admins: {e}")
        raise



@router.callback_query(F.data == "admin_test")
async def handle_admin_test(callback: CallbackQuery):
    try:
        await callback.message.edit_text(
            "‚úÖ –°–≤—è–∑—å —Å –∞–¥–º–∏–Ω—Å–∫–æ–π –≥—Ä—É–ø–ø–æ–π –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\n"
            "–ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ."
        )
        await callback.answer()
        logger.info(f"1007 | –ê–¥–º–∏–Ω {callback.from_user.id} –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª —Ä–∞–±–æ—Ç—É –±–æ—Ç–∞")
    except Exception as e:
        logger.error(f"Error in admin test callback: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞", show_alert=True)

@router.callback_query(F.data.startswith("hw_approve_"))
async def approve_homework(callback: CallbackQuery):
    try:
        user_id, course_id, lesson = parse_callback_data(callback.data)
        next_lesson = await get_next_lesson(user_id, course_id)
        
        moscow_tz = pytz.timezone('Europe/Moscow')
        current_time = datetime.now(moscow_tz)
        
        # Calculate next lesson time
        result = await safe_db_operation(
            'SELECT datetime(?, "+" || ? || " seconds")',
            (current_time.strftime('%Y-%m-%d %H:%M:%S'), str(get_lesson_delay()))
        )
        next_time = await result.fetchone()
        
        if not next_time:
            logger.error("1002 | Failed to calculate next lesson time")
            return
            
        next_lesson_time = next_time[0]
        logger.info(f"1003 | Next lesson scheduled for: {next_lesson_time}")
        
        next_lesson = lesson + 1
        
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        base_path = os.path.join(project_root, 'data', 'courses', course_id, f'lesson{next_lesson}')
        
        if not os.path.exists(base_path):
            logger.error(f"1004 | Lesson directory not found: {base_path}")
            raise FileNotFoundError(f"1005 | Lesson {next_lesson} directory not found")
            
        lesson_files = glob.glob(os.path.join(base_path, '*.*'))
        logger.info(f"1006 | Found {len(lesson_files)} files in lesson {next_lesson}")
        
        for file_path in lesson_files:
            file_name = os.path.basename(file_path)
            delay = extract_delay_from_filename(file_name) 
            
            # Simply store course-relative path
            course_path = f"courses/{course_id}/lesson{next_lesson}/{file_name}"
            db_path = course_path.replace('\\', '/')
            
            logger.debug(f"1007 | Scheduling file: {db_path} with delay {delay}s")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º safe_db_operation –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π —Å –ë–î
            await safe_db_operation('''
                INSERT INTO scheduled_files (user_id, course_id, lesson, file_name, send_at)
                VALUES (?, ?, ?, ?, datetime('now', '+' || ? || ' seconds'))
            ''', (user_id, course_id, next_lesson, db_path, str(delay)))
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –¥–æ–º–∞—à–∫–∏ —á–µ—Ä–µ–∑ safe_db_operation
            await safe_db_operation('''
                UPDATE homeworks 
                SET status = 'approved',
                    approval_time = datetime('now'),
                    next_lesson_at = ?
                WHERE user_id = ? AND course_id = ? AND lesson = ? AND status = 'pending'
            ''', (next_lesson_time, user_id, course_id, lesson))
            
            # –ò —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Ç–æ–∂–µ
            await safe_db_operation('''
                UPDATE user_states 
                SET current_state = 'waiting_next_lesson',
                    current_lesson = ?
                WHERE user_id = ?
            ''', (lesson + 1, user_id))
            
            # –£–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            await callback.message.answer("‚úÖ –î–æ–º–∞—à–Ω—è—è —Ä–∞–±–æ—Ç–∞ –ø—Ä–∏–Ω—è—Ç–∞! –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–∫ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ–∑–∂–µ.")
           
            logger.info(f"1008 | Database updated for user {user_id}, course {course_id}, lesson {lesson}")
                
    except Exception as e:
        logger.error(f"1009 | Error in approve_homework: {e}", exc_info=True)
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –¥–æ–º–∞—à–Ω–µ–π —Ä–∞–±–æ—Ç—ã")

@router.callback_query(F.data.startswith("hw_reject_"))
async def reject_homework(callback: CallbackQuery, bot: Bot):
    try:
        parts = callback.data.split("_")
        if len(parts) != 4:
            logger.error("Invalid callback data format")
            await callback.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
            return
            
        user_id = int(parts[2])
        course_id = parts[3]
        
        # Use safe_db_operation
        result = await safe_db_operation('''
            SELECT current_lesson 
            FROM user_courses 
            WHERE user_id = ? AND course_id = ?
        ''', (user_id, course_id))
        
        course_data = await result.fetchone()
        if not course_data:
            await callback.answer("‚ùå –ö—É—Ä—Å –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return
        
        lesson = course_data[0]  # Fix: Move this line before using lesson
        
        success = await process_homework_status(
            user_id=user_id,
            course_id=course_id,
            lesson=lesson,
            status='declined',
            admin_id=callback.from_user.id
        )
        
        if success:
            await callback.message.edit_text(
                callback.message.text + "\n\n‚ùå –î–æ–º–∞—à–Ω—è—è —Ä–∞–±–æ—Ç–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞!"
            )
            
            await bot.send_message(
                user_id,
                "‚ùå –í–∞—à–∞ –¥–æ–º–∞—à–Ω—è—è —Ä–∞–±–æ—Ç–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ."
            )
        else:
            await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ", show_alert=True)
            
    except Exception as e:
        logger.error(f"24 Error in reject_homework: {e}", exc_info=True)
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", show_alert=True)


@router.message(Command("progress", "status"))
async def show_progress(message: Message):
    try:
        result = await safe_db_operation('''
            SELECT us.current_lesson, us.current_state, 
                   c.course_name, h.next_lesson_at,
                   COUNT(CASE WHEN h.status = 'pending' THEN 1 END) as pending_hw
            FROM user_states us
            JOIN courses c ON us.course_id = c.course_id
            LEFT JOIN homeworks h ON us.user_id = h.user_id 
            WHERE us.user_id = ?
            GROUP BY us.user_id
        ''', (message.from_user.id,))
        
        user_id = message.from_user.id
        
        async with aiosqlite.connect(DB_PATH) as db:
            # Get user's current course and lesson status
            cursor = await db.execute('''
                SELECT us.current_lesson, us.current_state, 
                       c.course_name, h.next_lesson_at,
                       COUNT(CASE WHEN h.status = 'pending' THEN 1 END) as pending_hw
                FROM user_states us
                JOIN courses c ON us.course_id = c.course_id
                LEFT JOIN homeworks h ON us.user_id = h.user_id 
                WHERE us.user_id = ?
                GROUP BY us.user_id
            ''', (user_id,))
            result = await cursor.fetchone()
            
            if not result:
                await message.answer("‚ùå –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫—É—Ä—Å–∞")
                return
                
            lesson, state, course_name, next_lesson, pending_hw = result
            
            # Format next lesson time
            next_lesson_text = "–¥–æ—Å—Ç—É–ø–µ–Ω" if state == 'active' else \
                             f"–±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–µ–Ω {next_lesson}" if next_lesson else \
                             "–æ–∂–∏–¥–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è"
            
            await message.answer(
                f"üìä –í–∞—à –ø—Ä–æ–≥—Ä–µ—Å—Å:\n\n"
                f"üìö –ö—É—Ä—Å: {course_name}\n"
                f"üìù –¢–µ–∫—É—â–∏–π —É—Ä–æ–∫: {lesson}\n"
                f"üìÖ –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–∫: {next_lesson_text}\n"
                f"üìã –ù–µ–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã—Ö –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π: {pending_hw}"
            )
            
    except Exception as e:
        logger.error(f"28 Error in progress command: {e}")
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ")


# –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
async def process_homework_status(user_id: int, course_id: str, lesson: int, status: str, admin_id: int) -> bool:
    try:
        await safe_db_operation('''
            UPDATE homeworks 
            SET status = ?,
                admin_id = ?,
                approval_time = datetime('now')
            WHERE user_id = ? 
            AND course_id = ? 
            AND lesson = ?
            AND status = 'pending'
        ''', (status, admin_id, user_id, course_id, lesson))
        
        return True
        
    except Exception as e:
        logger.error(f"42 | Error processing homework status: {e}", exc_info=True)
        return False


@router.callback_query(F.data == "show_pending_hw")
async def show_pending_homeworks(callback: CallbackQuery):
    homeworks = await get_pending_homeworks()
    # Process homeworks...

# Add after imports
def parse_callback_data(callback_data: str) -> tuple[int, str, int]:
    """Parse callback data in format 'hw_approve_user_id_course_id_lesson'"""
    try:
        _, _, user_id, course_id, lesson = callback_data.split('_')
        return int(user_id), course_id, int(lesson)
    except (ValueError, IndexError) as e:
        logger.error(f"Failed to parse callback data: {callback_data}, error: {e}")
        raise ValueError(f"Invalid callback data format: {callback_data}")
